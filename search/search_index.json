{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A Python package for interacting with cTrader Open API.</p> <p>This package is developed and maintained by Spotware.</p> <p>You can use OpenApiPy on all kinds of Python apps, it uses Twisted to send and receive messages asynchronously.</p> <p>Github Repository: https://github.com/spotware/OpenApiPy</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install OpenApiPy from pip:</p> <pre><code>pip install ctrader-open-api\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from ctrader_open_api import Client, Protobuf, TcpProtocol, Auth, EndPoints\nfrom ctrader_open_api.messages.OpenApiCommonMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiCommonMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiModelMessages_pb2 import *\nfrom twisted.internet import reactor\n\nhostType = input(\"Host (Live/Demo): \")\nhost = EndPoints.PROTOBUF_LIVE_HOST if hostType.lower() == \"live\" else EndPoints.PROTOBUF_DEMO_HOST\nclient = Client(host, EndPoints.PROTOBUF_PORT, TcpProtocol)\n\ndef onError(failure): # Call back for errors\n    print(\"Message Error: \", failure)\n\ndef connected(client): # Callback for client connection\n    print(\"\\nConnected\")\n    # Now we send a ProtoOAApplicationAuthReq\n    request = ProtoOAApplicationAuthReq()\n    request.clientId = \"Your application Client ID\"\n    request.clientSecret = \"Your application Client secret\"\n    # Client send method returns a Twisted deferred\n    deferred = client.send(request)\n    # You can use the returned Twisted deferred to attach callbacks\n    # for getting message response or error backs for getting error if something went wrong\n    # deferred.addCallbacks(onProtoOAApplicationAuthRes, onError)\n    deferred.addErrback(onError)\n\ndef disconnected(client, reason): # Callback for client disconnection\n    print(\"\\nDisconnected: \", reason)\n\ndef onMessageReceived(client, message): # Callback for receiving all messages\n    print(\"Message received: \\n\", Protobuf.extract(message))\n\n# Setting optional client callbacks\nclient.setConnectedCallback(connected)\nclient.setDisconnectedCallback(disconnected)\nclient.setMessageReceivedCallback(onMessageReceived)\n# Starting the client service\nclient.startService()\n# Run Twisted reactor\nreactor.run()\n</code></pre>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#auth-class","title":"Auth Class","text":"<p>For authentication you can use the package Auth class, first create an instance of it:</p> <pre><code>from ctrader_open_api import Auth\n\nauth = Auth(\"Your App ID\", \"Your App Secret\", \"Your App redirect URI\")\n</code></pre>"},{"location":"authentication/#auth-uri","title":"Auth URI","text":"<p>The first step for authentication is sending user to the cTrader Open API authentication web page, there the user will give access to your API application to manage the user trading accounts on behalf of him.</p> <p>To get the cTrader Open API authentication web page URL you can use the Auth class getAuthUri method:</p> <p><pre><code>authUri = auth.getAuthUri()\n</code></pre> The getAuthUri has two optional parameters:</p> <ul> <li> <p>scope: Allows you to set the scope of authentication, the default value is trading which means you will have full access to user trading accounts, if you want to just have access to user trading account data then use accounts</p> </li> <li> <p>baseUri: The base URI for authentication, the default value is EndPoints.AUTH_URI which is https://connect.spotware.com/apps/auth</p> </li> </ul>"},{"location":"authentication/#getting-token","title":"Getting Token","text":"<p>After user authenticated your Application he will be redirected to your provided redirect URI with an authentication code appended at the end of your redirect URI:</p> <pre><code>https://redirect-uri.com/?code={authorization-code-will-be-here}\n</code></pre> <p>You can use this authentication code to get an access token from API, for that you can use the Auth class getToken method:</p> <pre><code># This method uses EndPoints.TOKEN_URI as a base URI to get token\n# you can change it by passing another URI via optional baseUri parameter\ntoken = auth.getToken(\"auth_code\")\n</code></pre> <p>Pass the received auth code to getToken method and it will give you a token JSON object, the object will have these properties:</p> <ul> <li> <p>accessToken: This is the access token that you will use for authentication</p> </li> <li> <p>refreshToken: This is the token that you will use for refreshing the accessToken onces it expired</p> </li> <li> <p>expiresIn: The expiry of token in seconds from the time it generated</p> </li> <li> <p>tokenType: The type of token, standard OAuth token type parameter (bearer)</p> </li> <li> <p>errorCode: This will have the error code if something went wrong</p> </li> <li> <p>description: The error description</p> </li> </ul>"},{"location":"authentication/#refreshing-token","title":"Refreshing Token","text":"<p>API access tokens have an expiry time, you can only use it until that time and once it expired you have to refresh it by using the refresh token you received previously.</p> <p>To refresh an access token you can use the Auth class refreshToken method:</p> <pre><code># This method uses EndPoints.TOKEN_URI as a base URI to refresh token\n# you can change it by passing another URI via optional baseUri parameter\nnewToken = auth.refreshToken(\"refresh_Token\")\n</code></pre> <p>You have to pass the refresh token to \"refreshToken\" method, and it will return a new token JSON object which will have all the previously mentioned token properties.</p> <p>You can always refresh a token, even before it expires and the refresh token has no expiry, but you can only use it once.</p>"},{"location":"client/","title":"Client","text":""},{"location":"client/#client-class","title":"Client Class","text":"<p>You will use an instance of this class to interact with API.</p> <p>Each instance of this class will have one connection to API, either live or demo endpoint.</p> <p>The client class is driven from Twisted ClientService class, and it abstracts away all the connection / reconnection complexities from you.</p>"},{"location":"client/#creating-a-client","title":"Creating a Client","text":"<p>Let's create an isntance of Client class:</p> <pre><code>from ctrader_open_api import Client, Protobuf, TcpProtocol, Auth, EndPoints\n\nclient = Client(EndPoints.PROTOBUF_DEMO_HOST, EndPoints.PROTOBUF_PORT, TcpProtocol)\n</code></pre> <p>It's constructor has several parameters that you can use for controling it behavior:</p> <ul> <li> <p>host: The API host endpoint, you can use either EndPoints.PROTOBUF_DEMO_HOST or EndPoints.PROTOBUF_LIVE_HOST</p> </li> <li> <p>port: The API host port number, you can use EndPoints.PROTOBUF_PORT</p> </li> <li> <p>protocol: The protocol that will be used by client for making connections, use imported TcpProtocol</p> </li> <li> <p>numberOfMessagesToSendPerSecond: This is the number of messages that will be sent to API per second, set it based on API limitations or leave the default value</p> </li> </ul> <p>There are three other optional parameters which are from Twisted client service, you can find their detail here: https://twistedmatrix.com/documents/current/api/twisted.application.internet.ClientService.html </p>"},{"location":"client/#sending-message","title":"Sending Message","text":"<p>To send a message you have to first create the proto message, ex:</p> <pre><code># Import all message types\nfrom ctrader_open_api.messages.OpenApiCommonMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiCommonMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiMessages_pb2 import *\nfrom ctrader_open_api.messages.OpenApiModelMessages_pb2 import *\n\n# ProtoOAApplicationAuthReq message\napplicationAuthReq = ProtoOAApplicationAuthReq()\napplicationAuthReq.clientId = \"Your App Client ID\"\napplicationAuthReq.clientSecret = \"Your App Client secret\"\n</code></pre> <p>After you created the message and populated its fields, you can send it by using Client send method:</p> <pre><code>deferred = client.send(applicationAuthReq)\n</code></pre> <p>The client send method returns a Twisted deferred, it will be called when the message response arrived, the callback result will be the response proto message.</p> <p>If the message send failed, the returned deferred error callback will be called, to handle both cases you can attach two callbacks for getting response or error:</p> <p><pre><code>def onProtoOAApplicationAuthRes(result):\n    print(result)\n\ndef onError(failure):\n    print(failure)\n\ndeferred.addCallbacks(onProtoOAApplicationAuthRes, onError)\n</code></pre> For more about Twisted deferreds please check their documentation: https://docs.twistedmatrix.com/en/twisted-16.2.0/core/howto/defer-intro.html</p>"},{"location":"client/#canceling-message","title":"Canceling Message","text":"<p>You can cancel a message by calling the returned deferred from Client send method Cancel method.</p> <p>If the message is not sent yet, it will be removed from the messages queue and the deferred Errback method will be called with CancelledError.</p> <p>If the message is already sent but the response is not received yet, then you will not receive the response and the deferred Errback method will be called with CancelledError.</p> <p>If the message is already sent and the reponse is received then canceling it's deferred will not have any effect.</p>"},{"location":"client/#other-callbacks","title":"Other Callbacks","text":"<p>The client class has some other optional general purpose callbacks that you can use:</p> <ul> <li> <p>ConnectedCallback(client): This callback will be called when client gets connected, use client setConnectedCallback method to assign a callback for it</p> </li> <li> <p>DisconnectedCallback(client, reason): This callback will be called when client gets disconnected, use client setDisconnectedCallback method to assign a callback for it</p> </li> <li> <p>MessageReceivedCallback(client, message): This callback will be called when a message is received, it's called for all message types, use setMessageReceivedCallback to assign a callback for it</p> </li> </ul>"}]}